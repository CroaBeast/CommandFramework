package me.croabeast.command;

import lombok.Getter;
import lombok.Setter;
import org.apache.commons.lang.StringUtils;
import org.bukkit.command.CommandSender;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;

/**
 * Represents a sub-command that is part of a parent command.
 * <p>
 * A {@code SubCommand} implements {@link BaseCommand} and encapsulates the name, permission node,
 * aliases, and executable predicate for a sub-command. Its permission node is automatically constructed by
 * appending the sub-command's name to its parent command's permission, and aliases can be specified by
 * separating them with a semicolon in the provided name string.
 * </p>
 * <p>
 * Example usage:
 * <pre><code>
 * // Create a sub-command with aliases "alt1" and "alt2":
 * SubCommand sub = new SubCommand(parentCommand, "mainName;alt1;alt2");
 * sub.setPredicate((sender, args) -&gt; {
 *     // Sub-command logic here.
 *     return true;
 * });
 * </code></pre>
 * </p>
 *
 * @see BaseCommand
 * @see Command
 * @see CommandPredicate
 */
@Getter @Setter
public class SubCommand implements BaseCommand {

    /**
     * The primary name of the sub-command.
     */
    private final String name;

    /**
     * The permission node for the sub-command.
     * <p>
     * This is automatically generated by concatenating the parent command's permission, a period,
     * and the sub-command's primary name.
     * </p>
     */
    private String permission;

    /**
     * The parent command to which this sub-command belongs.
     */
    private final Command parent;

    /**
     * A list of alias names for this sub-command.
     */
    private final List<String> aliases = new ArrayList<>();

    /**
     * The executable action to be performed when the sub-command is invoked.
     */
    private CommandPredicate predicate = null;

    /**
     * Constructs a new {@code SubCommand} for the specified parent command and name.
     * <p>
     * The {@code name} parameter can include aliases separated by a semicolon.
     * The first element is taken as the primary name, and the subsequent elements are added as aliases.
     * The permission node is automatically set as the parent command's wildcard permission
     * concatenated with the sub-command's primary name.
     * </p>
     *
     * @param parent the parent command (must not be {@code null}).
     * @param name   the sub-command name.
     * @param aliases the optional aliases.
     * @throws NullPointerException if the parent is {@code null} or if the name is blank.
     */
    public SubCommand(Command parent, String name, String... aliases) {
        this.parent = Objects.requireNonNull(parent, "Parent cannot be null");

        if (StringUtils.isBlank(name))
            throw new NullPointerException("Name is empty");

        this.name = name;
        this.permission = parent.getPermission() + '.' + this.name;

        List<String> list = Arrays.asList(aliases);
        this.aliases.addAll(list);
    }

    /**
     * Constructs a new {@code SubCommand} for the specified parent command and name.
     * <p>
     * The {@code name} parameter can include aliases separated by a semicolon.
     * The first element is taken as the primary name, and the subsequent elements are added as aliases.
     * The permission node is automatically set as the parent command's wildcard permission
     * concatenated with the sub-command's primary name.
     * </p>
     *
     * @param parent the parent command (must not be {@code null}).
     * @param name   the sub-command name, optionally including aliases separated by a semicolon.
     * @throws NullPointerException if the parent is {@code null} or if the name is blank.
     */
    public SubCommand(Command parent, String name) {
        this.parent = Objects.requireNonNull(parent, "Parent cannot be null");

        if (StringUtils.isBlank(name))
            throw new NullPointerException("Name is empty");

        List<String> list = new ArrayList<>(Arrays.asList(name.split(";")));
        this.name = list.get(0);
        this.permission = parent.getPermission() + '.' + this.name;
        if (list.size() == 1) return;

        for (int i = 1; i < list.size(); i++) aliases.add(list.get(i));
    }

    /**
     * Checks if the given {@link CommandSender} is permitted to execute this sub-command.
     * <p>
     * The permission check is performed using the default permission checker. The sender is granted permission
     * if they have the parent command's wildcard permission or the specific permission for this sub-command.
     * </p>
     *
     * @param sender the command sender to check.
     * @param log    whether to log the permission check result (not used in this implementation).
     * @return {@code true} if the sender is permitted; {@code false} otherwise.
     */
    @Override
    public boolean isPermitted(CommandSender sender, boolean log) {
        final SenderPredicate<String> checker = DefaultPermissible.DEFAULT_CHECKER;
        return checker.test(sender, parent.getWildcardPermission()) || checker.test(sender, permission);
    }

    /**
     * Returns the executable predicate for this sub-command.
     * <p>
     * If the executable predicate has not been set, a {@link NullPointerException} is thrown.
     * </p>
     *
     * @return the {@link CommandPredicate} representing the predicate of this sub-command.
     * @throws NullPointerException if the executable action is not set.
     */
    @NotNull
    public CommandPredicate getPredicate() {
        return Objects.requireNonNull(predicate, "Executable predicate is not set");
    }
}
