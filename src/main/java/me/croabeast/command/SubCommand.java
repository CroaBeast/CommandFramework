package me.croabeast.command;

import lombok.Getter;
import lombok.Setter;
import org.apache.commons.lang.StringUtils;
import org.bukkit.command.CommandSender;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;

/**
 * Represents a sub-command that belongs to a parent {@link Command}.
 * <p>
 * A {@code SubCommand} is a child command that extends the behavior of a parent command,
 * inheriting its permission hierarchy and providing additional functionality under the
 * parent's command namespace.
 * </p>
 * <p>
 * Sub-commands are automatically assigned a permission node based on the parent's permission
 * followed by a period and the sub-command's name (e.g., {@code "parent.permission.subname"}).
 * Permission checks support both the sub-command's own permission and the parent's wildcard
 * permission (e.g., {@code "parent.permission.*"}).
 * </p>
 * <p>
 * Aliases can be specified either explicitly through the constructor or by using a
 * semicolon-separated format in the name parameter (e.g., {@code "name;alias1;alias2"}).
 * </p>
 *
 * <p>
 * Example usage:
 * <pre>{@code
 * SubCommand sub = new SubCommand(parentCommand, "reload;rl") {
 *     @Override
 *     public boolean execute(CommandSender sender, String[] args) {
 *         // reload logic
 *         return true;
 *     }
 * };
 * parentCommand.getSubCommandMap().add(sub);
 * }</pre></p>
 *
 * @see Command
 * @see BaseCommand
 * @see SubCommandMap
 */
@Getter @Setter
public abstract class SubCommand implements BaseCommand {

    /**
     * The primary name of the sub-command.
     */
    private final String name;

    /**
     * The permission node for the sub-command.
     * <p>
     * This is automatically generated by concatenating the parent command's permission, a period,
     * and the sub-command's primary name.
     * </p>
     */
    private String permission;

    /**
     * The parent command to which this sub-command belongs.
     */
    private final Command parent;

    /**
     * A list of alias names for this sub-command.
     */
    private final List<String> aliases = new ArrayList<>();

    /**
     * Creates a new sub-command with the specified parent, name, and aliases.
     * <p>
     * The permission node is automatically generated as {@code parent.getPermission() + "." + name}.
     * </p>
     *
     * @param parent  the parent {@link Command} this sub-command belongs to; must not be {@code null}.
     * @param name    the primary name of the sub-command; must not be blank.
     * @param aliases optional alias names for the sub-command.
     *
     * @throws NullPointerException if {@code parent} is {@code null} or {@code name} is blank.
     */
    public SubCommand(Command parent, String name, String... aliases) {
        this.parent = Objects.requireNonNull(parent, "Parent cannot be null");

        if (StringUtils.isBlank(name))
            throw new NullPointerException("Name is empty");

        this.name = name;
        this.permission = parent.getPermission() + '.' + this.name;

        List<String> list = Arrays.asList(aliases);
        this.aliases.addAll(list);
    }

    /**
     * Creates a new sub-command with the specified parent and a semicolon-separated name string.
     * <p>
     * The first segment of the semicolon-separated string is used as the primary name,
     * and any additional segments are registered as aliases. For example, the input
     * {@code "reload;rl;r"} creates a sub-command named {@code "reload"} with aliases
     * {@code "rl"} and {@code "r"}.
     * </p>
     * <p>
     * The permission node is automatically generated as {@code parent.getPermission() + "." + name}.
     * </p>
     *
     * @param parent the parent {@link Command} this sub-command belongs to; must not be {@code null}.
     * @param name   the semicolon-separated name and alias string; must not be blank.
     *
     * @throws NullPointerException if {@code parent} is {@code null} or {@code name} is blank.
     */
    public SubCommand(Command parent, String name) {
        this.parent = Objects.requireNonNull(parent, "Parent cannot be null");

        if (StringUtils.isBlank(name))
            throw new NullPointerException("Name is empty");

        List<String> list = new ArrayList<>(Arrays.asList(name.split(";")));
        this.name = list.get(0);
        this.permission = parent.getPermission() + '.' + this.name;
        if (list.size() == 1) return;

        for (int i = 1; i < list.size(); i++) aliases.add(list.get(i));
    }

    /**
     * Checks whether the given sender has permission to use this sub-command.
     * <p>
     * Permission is granted if the sender has either the parent command's wildcard permission
     * (e.g., {@code "parent.permission.*"}) or this sub-command's specific permission node.
     * </p>
     *
     * @param sender the {@link CommandSender} to check permissions for.
     * @param log    whether to log the permission check result (unused in this implementation).
     *
     * @return {@code true} if the sender has the required permission; {@code false} otherwise.
     */
    @Override
    public boolean isPermitted(CommandSender sender, boolean log) {
        final SenderPredicate<String> checker = DefaultPermissible.DEFAULT_CHECKER;
        return checker.test(sender, parent.getPermission(true)) || checker.test(sender, permission);
    }
}
